HOWTO: Support for New Detectors to xia2
----------------------------------------

A new framework has been implemented within xia2 to make it more straight-
forward to add support for new detector types and beamlines. In essence all 
that is needed is to implement a Python class which extends the Format class
to add some specific details about this detector and the associated beamline / 
experimental environment.

In particular there are two groups of things which need to be implemented - 
a static method named "understand" which will take a look at the image and 
return an integer describing how well it understands it, and a bunch of class
methods which need to override the construction of the description.

"understand" Static Method
--------------------------

This method is the key to how the whole framework operates - you write code 
which looks at the image to decide whether it is right for this class. If it is
not you must return 0 - i.e. if you are making a custom class for a given 
detector serial number and it is given an image from a different detector.

Ideally your implementation will inherit from a similar Format class and just
apply further customizations. 

Class Methods
-------------

The class methods need to use the built in factories to construct descriptions
of the experimental apparatus from the image, namely the goniometer, detector,
beam and scan. In many cases the "simple" model will be the best which is 
often trivial. In other cases it may be more complex but will hopefully 
correspond to an already existing factory method.

Adding Support for RIGAKU SATURN
--------------------------------

The simplest way to demonstrate how to do something is to go ahead and do it - 
which is what we will do here. The Rigaku Saturn detectors record the images
as a comprehensive text header in SMV format followed by a straightforward
unsigned short matrix containing the pixel intensities. At this stage we will
focus on making use of the header information. However before we do anything,
obtain an example of the image you are trying to support - you will need this.

Fortunately there is already a parser available for SMV format images - 
FormatSMV - so we will make life a little easier by starting with that. Also 
let's call the class something clear like FormatSMVRigakuSaturn.py:

    #!/usr/bin/env python
    # FormatSMVRigakuSaturn.py
    #   Copyright (C) 2011 Diamond Light Source, Graeme Winter
    #
    #   This code is distributed under the BSD license, a copy of which is
    #   included in the root directory of this package.
    #
    # An implementation of the SMV image reader for Rigaku Saturn images.
    # Inherits from FormatSMV.

     from FormatSMV import FormatSMV

    class FormatSMVRigakuSaturn(FormatSMV):
        '''A class for reading SMV format Rigaku Saturn images, and correctly
        constructing a model for the experiment from this.'''

(if you are coding this in your $HOME/.xia2 directory, you may need to add 

    import os
    import sys
    assert (os.environ['XIA2_ROOT'] in sys.path)

    FormatRoot = os.path.append(os.environ['XIA2_ROOT'], 'Toolkit', 
                                'ImageFormat')

    if not FormatRoot in sys.path:
        sys.path.append(FormatRoot)

to the start of the class file. However I would personally just do all of the 
coding in the xia2 directory as that will keep things simple. Anyway, we 
digress. The first thing which needs to be added is a static method named
"understand" which will say how much sense we can make of this image and in 
essence whether this is the tool for the job. This cannot make use of any
of the class methods as it is static - however if you were to implement an
image header parser as a static method, that can be used here. Here we're in 
luck - the FormatSMV already has a static method which will return the contents
of the image header as a dictionary.

As this is a demonstration case, the check here is rather extensive looking
for every header keyword we will want. In general you would probably not 
be quite this thorough.

        @staticmethod
        def understand(image_file):
            '''Check to see if this looks like a Rigaku Saturn SMV format
            image, i.e. we can make sense of it. Essentially that will be if
            it contains all of the keys we are looking for.'''
            
            if FormatSMV.understand(image_file) == 0:
                return 0

            size, header = FormatSMV.get_smv_header(image_file)
            
            wanted_header_items = [
                'DETECTOR_NUMBER', 'DETECTOR_NAMES',
                'CRYSTAL_GONIO_NUM_VALUES', 'CRYSTAL_GONIO_NAMES',
                'CRYSTAL_GONIO_UNITS', 'CRYSTAL_GONIO_VALUES',
                'DTREK_DATE_TIME',
                'ROTATION', 'ROTATION_AXIS_NAME', 'ROTATION_VECTOR',
                'SOURCE_VECTORS', 'SOURCE_WAVELENGTH',
                'SOURCE_POLARZ', 'DIM', 'SIZE1', 'SIZE2',
                ]
            
            for header_item in wanted_header_items:
                if not header_item in header:
                    return 0
                
            detector_prefix = header['DETECTOR_NAMES'].split()[0].strip()
                
            more_wanted_header_items = [
                'DETECTOR_DIMENSIONS', 'DETECTOR_SIZE', 'DETECTOR_VECTORS',
            'GONIO_NAMES', 'GONIO_UNITS', 'GONIO_VALUES', 'GONIO_VECTORS',
                'SPATIAL_BEAM_POSITION'
                ]

            for header_item in more_wanted_header_items:
                if not '%s%s' % (detector_prefix, header_item) in header:
                    return 0

            return 2

And - just to make sure out coding is going along the right lines, let's
add a __main__ method to give it a tiny workout:

    if __name__ == '__main__':
        
        import sys
        
        for arg in sys.argv[1:]:
            print FormatSMVRigakuSaturn.understand(arg)

Clearly when you run this and give it an image from the right kind of detector
you would expect this to return at least 2. If it does not, then you have some
debugging to do. Let's assume it returns 2 - it does for me. It is then time
to implement the methods to do the rest of the work.

